[
["index.html", "Découvrir R et RStudio Chapitre 1 Introduction 1.1 Le parcours de formation 1.2 Objectifs du module 1", " Découvrir R et RStudio Thierry Zorn, Murielle Lethrosne, Vivien Roussez &amp; Pascal Irz 28 mai 2019 Chapitre 1 Introduction Crédit photographique Pascal Boulin 1.1 Le parcours de formation Ce dispositif de formation vise à faire monter en compétence les agents du MTES (Ministère de la transition écologique et solidaire) et du MCT (Ministère de la cohésion des territoires) dans le domaine de la science de la donnée avec le logiciel R. Il est conçu pour être déployé à l’échelle nationale par le réseau des CVRH (Centre de Valorisation des Ressources Humaines). Le parcours proposé est structuré en modules de 2 jours chacun. Les deux premiers (ou un niveau équivalent) sont des pré-requis pour suivre les suivants qui sont proposés “à la carte” : Socle : Premier programme en R Socle : Préparation des données Statistiques descriptives Analyses multivariées Datavisualisation : Produire des graphiques, des cartes et des tableaux Documents reproductibles avec RMarkdown (2ème semestre 2019) … et en perspective : analyse spatiale, applis interactives avec Shiny, big data, etc. La mise à disposition des supports de formation se fait désormais par la page d’accueil du parcours de formation. Ces supports sont en licence ouverte. Si vous souhaitez accéder aux sources, données mobilisées pendant les formations, il faut directement les télécharger depuis le Github du ministère. Pour vous tenir au courant de l’offre de formation proposée par le réseau des CVRH, [consultez la plateforme OUPS] (http://oups-cmvrh.e2.rie.gouv.fr/)(nécessite un accès intranet MTES-MCT). Vous pouvez vous y abonner pour recevoir les annonces qui vous intéressent. Il existe une liste pour diffuser de l’information, échanger autour de R ou lever des points de blocage. Pour s’insrire, envoyer un message vide avec le titre “subscribe labo.communaute-r” à l’adresse sympa@developpement-durable.gouv.fr. 1.2 Objectifs du module 1 Ce module vise à faire découvrir : R et son écosystème L’interface de RStudio Les méthodes élémentaires d’importation des données Des premières statistiques Des premières représentations graphiques Il s’agit d’avoir les clefs pour commencer à travailler rapidement sur R en complément, voire en remplacement d’autres outils (Excel, SAS…). Les concepts de programmation sont également abordés pour pouvoir comprendre les syntaxes proposées dans les différents forums d’aide. "],
["r-son-ecosysteme-et-ses-possibilites.html", "Chapitre 2 R, son écosystème et ses possibilités 2.1 Le groupe de référents 2.2 R c’est quoi ? 2.3 Un peu d’histoire 2.4 Un logiciel libre 2.5 Que peut-on faire avec R ? 2.6 Un logiciel modulaire 2.7 Des exemples de ce qu’on peut faire avec R :", " Chapitre 2 R, son écosystème et ses possibilités 2.1 Le groupe de référents Un groupe pour structurer une offre de formations sur R Un réseau d’entraide 2.2 R c’est quoi ? Un langage de programmation interprété exécutable pas à pas \\(\\rightarrow\\) lignes de code Un logiciel interactif permettant de traiter divers types de données 2.3 Un peu d’histoire A l’origine existait le langage S, servant à programmer avec des données (Bell laboratory, années 70) Au milieu des années 90, mélange de S et du langage Lisp pour le dédier à l’analyse de données et aux graphiques \\(\\rightarrow\\) création de R. Ihaka R, Gentleman R (1996) R: A Language for Data Analysis and Graphics. Journal of Computational and Graphical Statistics, 5(3), 299–314 S’est d’abord développé dans le monde académique, puis a essaimé vers d’autres domaines professionnels, voire associatifs Système toujours d’actualité - Mise à jour tous les 6 mois Avenir dans la statistique publique : Adopté comme standard par l’Insee (à l’horizon 2025) et divers SSM. Des packages pour : charger les données sdmx de l’Insee, charger les formats des organisations internationales (Eurostat, OCDE, ONU, etc.), gérer les millésimes du référentiel communal, etc. 2.4 Un logiciel libre Disponible en libre téléchargement sur le site officiel du CRAN Installable sur la plupart des systèmes d’exploitation Utilisé en recherche, en enseignement et en entreprise Une communauté très active : Forum des utilisateurs de R en français Communauté française des utilisateurs de R (avec des packages spécifiques, qui permettent de gérer les changements de géographie communale par exemple) : Frrrenchies Slack de ces utilisateurs (pour les questions/réponses, actualités…) Slack Forum des utilisateurs de R en français : http://forums.cirad.fr/logiciel-R/ R-bloggers : https://www.r-bloggers.com/ Stackoverflow : https://stackoverflow.com/questions/tagged/r C’est un logiciel libre : les utilisateurs ont la liberté d’exécuter, copier, distribuer, étudier, modifier et améliorer ce logiciel. R fait partie de la “galaxie” GNU (GNU’s Not Unix). R est donc libre, gratuit et multiplateforme. Le site CRAN = Comprehensive R Archive Network est le site de référence pour R. Il contient non seulement les installeurs du logiciel mais également de nombreuses ressources : documentations, FAQ, tutoriels… 2.5 Que peut-on faire avec R ? Lire des données de formats divers Les manipuler (prétraitements) Les enrichir à partir de données externes Les analyser, les modéliser Présenter les résultats (tableaux, graphiques, cartes) Publier … … et ce au moyen d’une palette de méthodes extrêmement diversifiée. Privilégie la flexibilité et le découpage des traitements en parties simples. 2.6 Un logiciel modulaire Le package base contient nombreuses fonctionnalités Extensible au moyen de packages (1 package = 1 ensemble de nouvelles fonctions) Nombreuses extensions spécialisées Proposition d’une version installable de R + ensemble de packages utiles De base, R permet déjà de faire un très grand nombre de choses avec son socle commun : le package base. Pour afficher la liste des fonctions disponibles dans le package base : library(help = &#39;base&#39;) Sur ce package base vient se greffer un ensemble de packages (plugins, modules) complémentaires. Un package est une bibliothèque de fonctions. La plupart de ceux qui font référence sont mis à disposition de tous sur le dépôt CRAN. Cela permet d’étendre à l’infini les possibilités de R : celles-ci sont seulement limitées par la volonté de développement des utilisateurs. De même que les packages sont dépendants de fonctions du module principal base, certains packages peuvent être dépendants de fonctionnalités d’autres packages \\(\\rightarrow\\) notion d’arbre des dépendances (géré par R de façon transparente). Sructure modulaire \\(\\rightarrow\\) il existe de multiple façons d’effectuer une même tâche. Il suffit d’une méthode maîtrisée pour aller au résultat. Les fonctionnalités utilisables dans R, sont en perpétuelle évolution et permettent d’intégrer les méthodes les plus récentes dans des domaines qui évoluent rapidement : modélisation, analyse spatiale, dataviz,… Le groupe des référents propose un pack d’installation comprenant R, RStudio et un ensemble de packages en phase avec le parcours de formation. Vous pouvez le télécharger ici en deux fichiers compressés (nécessite un accès intranet MTES-MCT). 2.7 Des exemples de ce qu’on peut faire avec R : Le support de cette formation Visualisation du compte du logement Les pesticides dans les cours d’eau des Pays de la Loire Des exemples de ce qu’on peut faire avec shiny "],
["presentation-de-linterface-et-premieres-manipulations.html", "Chapitre 3 Présentation de l’interface et premières manipulations 3.1 Une interface particulière : RStudio 3.2 Session et répertoire de travail 3.3 Exercice 3.4 Prise en main de la console 3.5 Création d’une variable 3.6 Exercice 3.7 Utilité des scripts 3.8 Exercice : utiliser un script", " Chapitre 3 Présentation de l’interface et premières manipulations 3.1 Une interface particulière : RStudio Environnement de développement conçu spécialement pour R Interface utilisateur simple, conviviale, configurable et intégrant plusieurs outils Disponible sur http://www.rstudio.com L’interface RStudio est composée de différents panneaux, dont l’arrangement peut être reconfiguré, incluant une console, un navigateur de fichiers et graphiques, l’espace de travail et l’historique des commandes. D’autres environnements graphiques existent, Rstudio semble le plus approprié à nos métiers Lancer le script exemple Démonstration : “./Presentation RStudio” 3.2 Session et répertoire de travail Session de travail R : commence à l’ouverture de RStudio et se termine en le quittant Répertoire de travail R : Dossier dans lequel le logiciel va chercher les fichiers de scripts et de données Tout ce qui a été fait au cours d’une session peut être enregistré dans le répertoire de travail : données historique des fonctions … Nouvelles fonctions Attention setwd() pour définir un répertoire de travail Seulement / et pas \\ help() et ? pour afficher l’aide . dir() pour lister un répertoire . Attention avec le répertoire de travail : si on l’écrit en dur setwd('...'), les anti-slash windows (\\) doivent être remplacés par des slash(/) Concernant le répertoire de travail, quelques conseils : Créer un nouveau répertoire pour un projet particulier qui sera votre répertoire de travail Créer des sous-répertoires dans ce répertoire : “./Data”, “./Figures”, “./Redaction”… Rassembler autant que possible les fichiers qui seront utilisés dans le cadre de ce projet et éviter d’aller chercher des fichiers ailleurs 3.3 Exercice Sur le poste de travail, créer un dossier devant servir de dossier de travail au cours de la formation. Dans Rstudio, définir ce dossier comme répertoire de travail directement en utilisant setwd('') Appeler l’aide en ligne par ?setwd ou help(setwd) Faire une recherche dans la partie Help de RStudio Lire le contenu du répertoire de travail avec dir() 3.4 Prise en main de la console Effectuer et afficher les résultats de calculs de base (+, -, *, /, ^, ...) Utiliser des fonctions spécifiques : sum, abs, round… On peut remonter dans l’historique des fonctions pour en rappeler une Nouvelles fonctions Attention sum() pour sommer un résultat Séparateur décimal point (.) abs() pour retourner la valeur absolue . round() pour arrondir un nombre . flèches pour naviguer dans l’historique . 3.5 Création d’une variable On assigne un contenu à une variable au moyen de &lt;- ma_variable &lt;- 2 ma_variable &lt;- &quot;Toulouse&quot; ma_variable &lt;- c(&quot;Toulouse&quot;, &quot;Nantes&quot;, &quot;Strasbourg&quot;) ma_variable &lt;- 1:10 \\(\\rightarrow\\) Les variables peuvent être numérique, texte ou boléen (TRUE/FALSE) et elles peuvent être réutilisées. Nouvelles fonctions Attention pour le nommage des variables ls() pour faire lister les variables existantes Casse -&gt; seulement minuscules paste() pour concaténer des variables textes Pas de caractères spéciaux ni accentués rm() pour supprimer une variable Pas d’espaces ni tirets (-) ; préférer (_) Adopter des règles de nommage cohérentes, par exemples celles-ci. 3.6 Exercice Créer plusieurs variables numériques par assignation a &lt;- 5, b &lt;- 4 Regarder l’onglet Environnement Afficher la liste des variables avec la fonction ls() Faire un calcul avec ces variables et voir le résultat (a+b) etc. Créer une troisième variable à partir des deux premières c &lt;- a+b*3 Ré-assigner une variable : a&lt;-10 et vérifier l’onglet environnement Créer une variable chaîne de caractère (utilisation des simples quotes et des double-quotes) t &lt;- 'chaine' Concaténer a et t avec paste(a,t) Expérimenter la casse des noms de variables : créer A &lt;- 15 et B &lt;- 12 et vérifier l’onglet environnement Supprimer les variables A et B avec la fonction rm() Aide en ligne ?ls et ?rm Attention : Pour supprimer toutes les variables rm(list = ls()) 3.7 Utilité des scripts Garder la trace d’une longue succession de lignes de code Pouvoir exécuter ce code (pas à pas ou en entier) Le modifier plus rapidement pour l’adapter Pouvoir le réutiliser avec de nouvelles données Nouvelles fonctions Attention # pour des commentaires explicatifs du code Importance de bien commenter print() pour afficher sur la console . Ctrl+R pour lancer un script ligne par ligne . Utilisation simple de R \\(\\rightarrow\\) mode console. Chaque ordre, bout de code est rentré et exécuté au fur et à mesure sur la console. Actions plus complexes, longues, nécessitant une maintenance, des modifications \\(\\rightarrow\\) travailler à partir de la fenêtre éditeur. Les parties de code sont enchaînées et enregistrées sous la forme d’un fichier texte réutilisable par la suite. Toujours utiliser des commentaires. Permet de pouvoir mieux comprendre ce que l’on a fait lorsqu’on reprend un programme plus tard ou lorsqu’on le donne à quelqu’un. 3.8 Exercice : utiliser un script Recopier le script ci-dessous et changer les paramètres pour le re-exécuter plusieurs fois Sauvegarder ce script dans votre répertoire de travail Fermer RStudio, le rouvrir, et réexécuter le script # Supprimer toutes les variables existantes rm(list = ls()) # Création de mes variables taille et poids ; attention au point décimal poids &lt;- 91 taille &lt;- 1.87 # Calcul de l&#39;IMC : poids sur taille au carré imc &lt;- poids / (taille ^ 2) # Affichage du résultat print (imc) ## [1] 26.02305 "],
["mon-premier-jeu-de-donnees.html", "Chapitre 4 Mon premier jeu de données 4.1 Les types de valeurs dans R 4.2 Avant de manipuler le dataframe : installer et charger un package 4.3 Importation de données 4.4 Structure des données : le dataframe 4.5 Gérer le type des variables 4.6 Les valeurs particulières 4.7 Exercice : Importer les données et premier coup d’oeil", " Chapitre 4 Mon premier jeu de données 4.1 Les types de valeurs dans R Une valeur constitue l’unité de base des données pour R. Comme pour la plupart des logiciels, elles peuvent être de trois types : Numérique : entier, double Caractère : texte ou code Logique : booléens Ces valeurs sont ensuites structurées au sein de vecteur qui sont compilés dans des dataframes. 4.2 Avant de manipuler le dataframe : installer et charger un package Pour manipuler notre base de données, nous allons nous servir de fonctionnalités présentes dans le package tidyverse. La première fois que l’on veut utiliser un package, il faut le télécharger sur notre ordinateur, avec install.packages() : install.packages(&quot;tidyverse&quot;) Puis à l’ouverture d’une session R, le charger (si on a besoin de ses fonctions), avec library() : library(&quot;tidyverse&quot;) Le package est prêt à être utilisé ! 4.3 Importation de données Conseil : exporter les données au format .csv ; c’est le format le plus interopérable (supporté par tous les logiciels stat). Utiliser ensuite la fonction read.csv après avoir défini le répertoire de travail (ou en donnant le chemin complet) base &lt;- read.csv (file = &quot;data/Base_synth_territoires.csv&quot;, header = T, sep = &quot;;&quot;, dec = &quot;,&quot;) header =indique la présence des noms de variable sur la première ligne sep = indique le séparateur de champ : ‘;’ ‘/t’ pour tabulation. dec = indique le séparateur de décimale (‘.’ par défaut) colClasses =permet de préciser le type de la données en entrée \\(\\Rightarrow\\) ?read.csv pour plus d’options Autres façons d’importer les données Fonction read_delim, du package readr, plus rapide Fonction fread, du package data.table, beaucoup plus rapide !! Pour importer les fichiers XLS, ODT ou DBF, il existe des fonctions et des packages spécifiques Le passage par un fichier csv est très recommandé 4.4 Structure des données : le dataframe n lignes (observations) p colonnes (variables) nrow (base) ## [1] 36689 ncol (base) ## [1] 38 dim (base) ## [1] 36689 38 4.5 Gérer le type des variables À chaque type de variable (numéric, factor,…) correspond une utilisation. Lors de l’import de données, un type est affecté automatiquement par R. Mais le type peut être erronné. Il suffit alors de de les convertir : base &lt;- mutate(base, LIBGEO = as.character (LIBGEO)) ou as.factor(), as.numeric(), etc… Pour être sûr de ne pas faire de bêtise, il vaut mieux gérer les types au moment de l’importation avec le paramètre colClasses \\(\\rightarrow\\) exercice ! 4.6 Les valeurs particulières NA : Valeur manquante (Not Available) NaN : Pas un nombre (Not a Number, e.g., 0/0) -Inf, Inf : Inﬁni positif ou négatif, e.g. 1/0 V1 &lt;- c(1, 14, NA, 32.7) mean(V1) # renvoie NA. Not good ! ## [1] NA mean(V1, na.rm = T) # renvoie 15.9 - OK ! ## [1] 15.9 \\(\\Rightarrow\\) Le module 2 “Préparation des données” aborde la gestion de ces valeurs particulières. 4.7 Exercice : Importer les données et premier coup d’oeil On peut importer n’importe quel format de données en R (Excel, SAT, Stata, SQL…). Beaucoup sont abordés lors du module 2 “Préparation des données”. Pour ce module, nous ne voyons que l’importation de fichier .CSV. Si vous avez une base de données en Excel ou LibreOffice Calc, sauvegardez l’onglet que vous souhaitez en faisant “enregistrer sous” \\(\\rightarrow\\) “délimité CSV”. Ici, nous travaillerons sur une base de données communales fournie par l’Insee, dite “comparateur de territoires”. Le fichier source (Excel) figure dans le sous-répertoire “data” et contient toutes les métadonnées. Utiliser la fonction read.csv() pour importer ce fichier et stockez le dans un objet df. Veillez à ce que la région soit bien importée comme un facteur et non un entier. Inspecter le dataframe avec les fonctions vues auparavant df &lt;- read.csv(file = &quot;data/Base_synth_territoires.csv&quot;, sep = &quot;;&quot;, dec = &quot;,&quot;, colClasses = c(NA, &quot;NULL&quot;, &quot;character&quot;, &quot;NULL&quot;,&quot;NULL&quot;,&quot;NULL&quot;, NA, NA, NA, NA, rep(&quot;NULL&quot;, 28))) str(df) ## &#39;data.frame&#39;: 36689 obs. of 6 variables: ## $ CODGEO : Factor w/ 36689 levels &quot;01001&quot;,&quot;01002&quot;,..: 1 2 3 4 5 6 7 8 9 10 ... ## $ REG : chr &quot;84&quot; &quot;84&quot; &quot;84&quot; &quot;84&quot; ... ## $ P14_POP : int 767 239 14022 1627 109 2570 743 338 1142 397 ... ## $ P09_POP : int 787 207 13350 1592 120 2328 660 336 960 352 ... ## $ SUPERF : num 15.95 9.15 24.6 15.92 5.88 ... ## $ NAIS0914: int 40 16 1051 117 8 175 59 12 56 25 ... On peut également gérer les problèmes d’encodage de caractères (si on passe de Windows à un système Unix, par exemple). head(df) ## CODGEO REG P14_POP P09_POP SUPERF NAIS0914 ## 1 01001 84 767 787 15.95 40 ## 2 01002 84 239 207 9.15 16 ## 3 01004 84 14022 13350 24.60 1051 ## 4 01005 84 1627 1592 15.92 117 ## 5 01006 84 109 120 5.88 8 ## 6 01007 84 2570 2328 33.55 175 tail(df) ## CODGEO REG P14_POP P09_POP SUPERF NAIS0914 ## 36684 97419 04 6722 6822 177.60 519 ## 36685 97420 04 22406 22437 57.84 1963 ## 36686 97421 04 7132 7406 103.82 661 ## 36687 97422 04 76796 72658 165.43 6663 ## 36688 97423 04 7198 7057 42.58 531 ## 36689 97424 04 5295 5989 84.40 430 names(df) ## [1] &quot;CODGEO&quot; &quot;REG&quot; &quot;P14_POP&quot; &quot;P09_POP&quot; &quot;SUPERF&quot; &quot;NAIS0914&quot; class(df) # la classe de l&#39;objet (du point de vue langage orienté objet) ## [1] &quot;data.frame&quot; typeof(df) # le type d&#39;objet du point de vue &quot;interne&quot; à R ## [1] &quot;list&quot; # Accéder a une variable directement (on obtient un vecteur), grâce à $ : df$CODGEO[1:10] # Captain crochet poweeeeerr !!! ## [1] 01001 01002 01004 01005 01006 01007 01008 01009 01010 01011 ## 36689 Levels: 01001 01002 01004 01005 01006 01007 01008 01009 01010 ... 97424 class(df$CODGEO) ## [1] &quot;factor&quot; typeof(df$CODGEO) ## [1] &quot;integer&quot; length(df) ## [1] 6 length(df$REG) ## [1] 36689 "],
["bien-commencer.html", "Chapitre 5 Bien commencer 5.1 Créer un projet sous Rstudio pour vous permettre de recencer vos travaux. 5.2 Intégrer vos données 5.3 Créer votre arborescence de projet 5.4 Activer les packages nécessaires 5.5 Bien structurer ses projets data", " Chapitre 5 Bien commencer 5.1 Créer un projet sous Rstudio pour vous permettre de recencer vos travaux. Pourquoi travailler avec les projets Rstudio plutôt que les scripts R ? Cela permet la portabilité : le répertoire de travail par défaut d’un projet est le répertoire où est ce projet. Si vous transmettez celui-ci à un collègue, le fait de lancer un programme ne dépend pas de l’arborescence de votre machine. Fini les setwd(&quot;chemin/qui/marche/uniquement/sur/mon/poste&quot;) ! Toujours sur la portabilité, un projet peut être utilisé avec un outil comme packrat qui va vous intégrer en interne au projet l’ensemble des packages nécessaires au projet. Cela permet donc à votre collègue à qui vous passez votre projet de ne pas avoir à les installer et, surtout, si vous mettez à jour votre environnement R, votre projet restera toujours avec les versions des packages avec lesquelles vous avez fait tourner votre projet à l’époque. Cela évite d’avoir à subir les effets d’une mise à jour importante d’un package qui casserait votre code. Pour activer packrat sur un projet, aller dans Tools/Project Options-&gt;Packrat En savoir plus sur Packrat Cela permet de se forcer à travailler en mode projet : on intègre à un seul endroit tout ce qui est lié à un projet : données brutes, données retravaillées, scripts, illustrations, documentations, publications… et donc y compris les packages avec packrat. On peut travailler sur plusieurs projets en même temps, Rstudio ouvre autant de sessions que de projets dans ce cas. Les projets Rstudio intègrent une interface avec les outils de gestion de version Git et SVN. Cela veut dire que vous pouvez versionniser votre projet et l’héberger simplement comme répertoire sur des plateformes de gestion de code telle que Github ou Gitlab. Pour créer un projet : Cliquez sur Project en haut à droite puis New Project. Cliquez sur New Directory. 5.2 Intégrer vos données Une bonne pratique est de créer un sous répertoire /data pour stocker les données sur lesquelles vous aurez à travailler. Vous pouvez le faire depuis l’explorateur de fichier de votre système d’exploitation ou directement à partir de l’explorateur de fichier de RStudio. Cela marche bien quand on a un seul type de données, mais en général on va avoir à travailler sur des données brutes que l’on va retravailler ensuite et vouloir stocker à part. Si par la suite vous souhaitez avoir des exemples de bonnes pratiques sur comment structurer vos données, vous pouvez vous référer au chapitre data du livre d’Hadley Wickham sur la construction de packages R (tout package R étant aussi un projet !). 5.3 Créer votre arborescence de projet Créer un répertoire /src ou vous mettrez vos scripts R. Créer un répertoire /figures ou vous mettrez vos illustrations issues de R. 5.4 Activer les packages nécessaires Commencer par rajouter un script dans le répertoire /src à votre projet qui commencera par : activer l’ensemble des packages nécessaires charger les données dont vous aurez besoin. library(tidyverse) library(GGally) library(plotly) base &lt;- read.csv (file = &quot;data/Base_synth_territoires.csv&quot;, header = T, sep = &quot;;&quot;, dec = &quot;,&quot;) 5.5 Bien structurer ses projets data Plusieurs documents peuvent vous inspirer sur la structuration de vos projets data par la suite. En voici quelques uns : https://github.com/pavopax/new-project-template https://nicercode.github.io/blog/2013-04-05-projects/ https://www.inwt-statistics.com/read-blog/a-meaningful-file-structure-for-r-projects.html http://projecttemplate.net/architecture.html A partir du moment où quelques grands principes sont respectés (un répertoire pour les données brutes en lecture seule par exemple), le reste est surtout une question d’attirance plus forte pour l’une ou l’autre solution. L’important est de vous tenir ensuite à conserver toujours la même arborescence dans vos projets afin de vous y retrouver plus simplement. "],
["premiere-manipulation-des-donnees.html", "Chapitre 6 Première manipulation des données 6.1 Afficher les valeurs et manipuler les variables 6.2 Créer de nouvelles variables 6.3 Sélectionner des variables 6.4 Filtrer des observations 6.5 Les tests logiques dans R 6.6 Renommer des colonnes 6.7 Exercice : Créer, filtrer, sélectionner", " Chapitre 6 Première manipulation des données 6.1 Afficher les valeurs et manipuler les variables Pour afficher la table, plusieurs façon : “clic” dans l’environnement Rstudio, View(base), print(base), base. Pour accéder à une variable : fonction pull() Par exemple : str(pull(base, DEP)) ## Factor w/ 100 levels &quot;01&quot;,&quot;02&quot;,&quot;03&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... 6.2 Créer de nouvelles variables La fonction mutate() permet de créer/modifier une variable (ou plusieurs). TableEnSortie &lt;- mutate(TableEnEntree, NouvelleVariable = DefinitionDeLaVariable) Par exemple : base &lt;- mutate(base, log_SUPERF = log(SUPERF)) Nb : mutate() permet également de modifier une variable. Dans ce cas la syntaxe est la même que ci-dessus, mais les noms d’entrée et de sortie sont les mêmes : base &lt;- mutate(base, log_SUPERF = 100 * log_SUPERF) \\(\\Rightarrow\\) La table base contient de nouvelles colonnes 6.3 Sélectionner des variables La fonction select() permet de sélectionner les variables voulues. sélection par liste blanche TableEnSortie &lt;- select(TableEnEntree, Variable1, Variable2, ..., VariableN) sélection par liste noire (supprimer) TableEnSortie &lt;- select(TableEnEntree, -Variable1, -Variable2, ..., -VariableN) Par exemple : base_select &lt;- select(base, CODGEO, LIBGEO, P14_POP) base_select &lt;- select(base, -CODGEO) 6.4 Filtrer des observations La fonction filter() permet de sélectionner les observations, selon une condition (ou plusieurs). TableEnSortie &lt;- filter(TableEnSortie, Condition1, ..., ConditionN) Par exemple : base_filter &lt;- filter(base, DEP == &quot;01&quot; &amp; P14_POP &gt; 10000) \\(\\Rightarrow\\) Attention à l’opérateur de comparaison : &quot; == &quot; et non pas “=” 6.5 Les tests logiques dans R Syntaxe Action == Test d’égalité != Différent de %in% c(…) Dans une liste de valeurs \\(&gt;, &gt;=\\) \\(&lt;, &lt;=\\) Supérieur (ou inférieur) (ou égal) ! (x %in% c(…)) N’est pas dans une liste de valeurs TableEnSortie &lt;- filter(TableEnSortie, x==a &amp; y==b) # x vaut a **ET** y vaut b TableEnSortie &lt;- filter(TableEnSortie, x==a | y==b) # x vaut a **OU** y vaut b (barre verticale AltGR+6) 6.6 Renommer des colonnes La fonction rename() permet de renommer une variable (ou plusieurs). base &lt;- rename(base, nouveau_nom = ancien_nom) Exemple base_rename &lt;- rename(base, ZONE_EMPLOI = ZE) 6.7 Exercice : Créer, filtrer, sélectionner En utilisant la fonction mutate(), créer une nouvelle variable correspondant à la densité de population (rapport de la population à la superficie de la commune), ainsi que les taux de natalité et de mortalité (en pour mille) A l’aide de la fonction select(), créer une nouvelle table en ne conservant que le code commune, le type de commune (ZAU), la région, le département et les variables que vous venez de créer. Enfin, ne conserver les communes correspondant à votre département de naissance et stocker ce dataframe. Attention au type de la variable département ! Avec les opérateurs logiques, faire des essais pour sélectionner des échantillons différents. df &lt;- mutate(base, densite = P14_POP / SUPERF, tx_natal = 1000 * NAISD15 / P14_POP, tx_mort = DECESD15 / P14_POP) selection &lt;- select(df, CODGEO, ZAU, REG, DEP, densite, tx_natal, tx_mort) S0 &lt;- filter(selection, DEP == &quot;62&quot;) S1 &lt;- filter(selection, DEP != &quot;62&quot;) # tout sauf le 62 :( S2 &lt;- filter(selection, DEP %in% c(&quot;59&quot;, &quot;62&quot;)) # L&#39;ancien NPdC :) S3 &lt;- filter(selection, !(DEP %in% c(&quot;59&quot;, &quot;62&quot;))) # Le &quot;sud&quot; de la France S4 &lt;- filter(selection, densite &gt; 100) # l&#39;urbain S5 &lt;- filter(selection, DEP == &quot;62&quot; &amp; densite &gt; 100) # le PdC urbain S6 &lt;- filter(selection, DEP == &quot;62&quot; | densite &gt; 100) # le PdC et l&#39;urbain Nom d’un pipe %&gt;% ! On peut combiner les opérations en une seule ligne à l’aide du pipe %&gt;% : selection_62 &lt;- select(df, CODGEO, ZAU, REG, DEP, densite, tx_natal) %&gt;% filter(DEP == &quot;62&quot;) "],
["premiers-traitements-statistiques.html", "Chapitre 7 Premiers traitements statistiques 7.1 Obtenir des informations 7.2 Calculer des statistiques spécifiques 7.3 Agréger des données 7.4 Tableau de contingence 7.5 Tableau de proportions 7.6 Exercice : calcul de statistiques", " Chapitre 7 Premiers traitements statistiques 7.1 Obtenir des informations La fonction summary() peut s’appliquer à une table entière ou un vecteur. Appliquée sur un tableau, elle donne les statistiques principales sur chacune des variables, en s’adaptant au type de celles-ci (numerique ou texte). base_extrait &lt;- select(base, 1, 3, 5, 7:12) summary(base_extrait) ## CODGEO REG ## 01001 : 1 Min. : 1.00 ## 01002 : 1 1st Qu.:28.00 ## 01004 : 1 Median :44.00 ## 01005 : 1 Mean :52.05 ## 01006 : 1 3rd Qu.:76.00 ## 01007 : 1 Max. :94.00 ## (Other):36683 ## ZAU P14_POP ## 112 - Couronne d&#39;un grand pôle :12297 Min. : 0 ## 400 - Commune isolée hors influence des pôles : 7383 1st Qu.: 197 ## 300 - Autre commune multipolarisée : 7021 Median : 444 ## 120 - Multipolarisée des grandes aires urbaines: 3962 Mean : 1838 ## 111 - Grand pôle (plus de 10 000 emplois) : 3285 3rd Qu.: 1110 ## 221 - Petit pôle (de 1 500 à 5 000 emplois) : 888 Max. :2220445 ## (Other) : 1853 NA&#39;s :821 ## P09_POP SUPERF NAIS0914 ## Min. : 0 Min. : 0.04 Min. : 0.0 ## 1st Qu.: 193 1st Qu.: 6.44 1st Qu.: 9.0 ## Median : 431 Median : 10.81 Median : 23.0 ## Mean : 1793 Mean : 17.64 Mean : 114.4 ## 3rd Qu.: 1072 3rd Qu.: 18.58 3rd Qu.: 60.0 ## Max. :2234105 Max. :18360.00 Max. :150843.0 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 ## DECE0914 P14_MEN ## Min. : 0.00 Min. : 0.0 ## 1st Qu.: 8.00 1st Qu.: 83.8 ## Median : 17.00 Median : 183.2 ## Mean : 77.35 Mean : 802.0 ## 3rd Qu.: 43.00 3rd Qu.: 454.9 ## Max. :69907.00 Max. :1147990.9 ## NA&#39;s :821 NA&#39;s :821 Les variables quantitatives summary(pull(base_extrait, NAIS0914)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 0.0 9.0 23.0 114.4 60.0 150843.0 821 Les variables qualitatives summary(pull(base_extrait, ZAU)) ## 111 - Grand pôle (plus de 10 000 emplois) ## 3285 ## 112 - Couronne d&#39;un grand pôle ## 12297 ## 120 - Multipolarisée des grandes aires urbaines ## 3962 ## 211 - Moyen pôle (5 000 à 10 000 emplois) ## 456 ## 212 - Couronne d&#39;un moyen pôle ## 815 ## 221 - Petit pôle (de 1 500 à 5 000 emplois) ## 888 ## 222 - Couronne d&#39;un petit pôle ## 582 ## 300 - Autre commune multipolarisée ## 7021 ## 400 - Commune isolée hors influence des pôles ## 7383 7.2 Calculer des statistiques spécifiques Les fonctions sum(), mean(), median(), min(), max(), var(), sd()… résument l’information pour en donner une statistique. La fonction quantile() renvoie les quartiles de la variables (ou bien tout autre découpage qu’on lui renseigne). sum(pull(base_extrait, P14_POP), na.rm = T) ## [1] 65907160 mean(pull(base_extrait, P14_POP), na.rm = T) ## [1] 1837.492 median(pull(base_extrait, P14_POP), na.rm = T) ## [1] 444 quantile(pull(base_extrait, P14_POP), probs = c(0.25, 0.5, 0.75), na.rm = T) ## 25% 50% 75% ## 197 444 1110 Ces fonctions retournent une valeur, ou bien un ensemble de valeur (pour quantile()). Le résultat est donc un vecteur de un ou plusieurs nombres. 7.3 Agréger des données 7.3.1 Globalement La fonction summarise() permet d’aggréger des données, en appliquant une fonction sur les variables pour construire une statistique sur les observations de la table. C’est une fonction dite de “résumé”. summarise (TableEnEntree, NomVariableAgregee = Fonction(NomVariableEtude)) base_med &lt;- base_extrait %&gt;% summarise(population_med = median(P14_POP, na.rm = T)) La fonction summarise() retourne un data.frame. 7.3.2 Selon un facteur La fonction summarise() couplée à group_by() permet de calculer des statistiques pour chaque modalité d’une variable qualitative. Avec group_by(), on précise les variables qui formeront des groupes, sur lesquels on appliquera une fonction : TableauGroupes &lt;- group_by (TableEnEntree, Variable1, ..., VariableN) summarise (TableauGroupes, NomVariableAgregee = Fonction (NomVariableEtude)) Par exemple, si on veut avoir la médiane de la variable P14_POP, pour chaque ZAU et chaque région : base_reg_ann &lt;- group_by (base_extrait, ZAU, REG) %&gt;% summarise (population_med = median (P14_POP, na.rm = T)) 7.4 Tableau de contingence La fonction table() calcule les effectifs d’un tableau croisé : t &lt;- table(base_extrait$ZAU, base_extrait$REG) print(t) ## ## 1 2 3 4 11 ## 111 - Grand pôle (plus de 10 000 emplois) 17 16 3 10 413 ## 112 - Couronne d&#39;un grand pôle 6 0 3 3 853 ## 120 - Multipolarisée des grandes aires urbaines 1 4 0 4 3 ## 211 - Moyen pôle (5 000 à 10 000 emplois) 0 3 2 2 3 ## 212 - Couronne d&#39;un moyen pôle 0 0 0 0 2 ## 221 - Petit pôle (de 1 500 à 5 000 emplois) 3 2 1 0 0 ## 222 - Couronne d&#39;un petit pôle 0 0 0 0 0 ## 300 - Autre commune multipolarisée 2 4 0 1 7 ## 400 - Commune isolée hors influence des pôles 3 5 13 4 0 ## ## 24 27 28 32 44 ## 111 - Grand pôle (plus de 10 000 emplois) 103 140 216 481 322 ## 112 - Couronne d&#39;un grand pôle 734 1299 1126 1505 1721 ## 120 - Multipolarisée des grandes aires urbaines 188 336 488 729 822 ## 211 - Moyen pôle (5 000 à 10 000 emplois) 30 31 34 33 54 ## 212 - Couronne d&#39;un moyen pôle 72 122 104 18 102 ## 221 - Petit pôle (de 1 500 à 5 000 emplois) 46 60 78 54 89 ## 222 - Couronne d&#39;un petit pôle 19 137 29 18 118 ## 300 - Autre commune multipolarisée 375 737 762 711 1155 ## 400 - Commune isolée hors influence des pôles 275 969 396 289 815 ## ## 52 53 75 76 84 ## 111 - Grand pôle (plus de 10 000 emplois) 108 89 333 258 548 ## 112 - Couronne d&#39;un grand pôle 535 415 1161 1124 1484 ## 120 - Multipolarisée des grandes aires urbaines 186 152 254 333 390 ## 211 - Moyen pôle (5 000 à 10 000 emplois) 23 47 51 79 43 ## 212 - Couronne d&#39;un moyen pôle 44 18 81 155 84 ## 221 - Petit pôle (de 1 500 à 5 000 emplois) 69 42 163 123 113 ## 222 - Couronne d&#39;un petit pôle 8 1 81 89 47 ## 300 - Autre commune multipolarisée 386 325 1002 877 517 ## 400 - Commune isolée hors influence des pôles 143 181 1379 1527 963 ## ## 93 94 ## 111 - Grand pôle (plus de 10 000 emplois) 220 8 ## 112 - Couronne d&#39;un grand pôle 229 99 ## 120 - Multipolarisée des grandes aires urbaines 69 3 ## 211 - Moyen pôle (5 000 à 10 000 emplois) 20 1 ## 212 - Couronne d&#39;un moyen pôle 11 2 ## 221 - Petit pôle (de 1 500 à 5 000 emplois) 32 13 ## 222 - Couronne d&#39;un petit pôle 6 29 ## 300 - Autre commune multipolarisée 107 53 ## 400 - Commune isolée hors influence des pôles 269 152 7.5 Tableau de proportions La fonction prop.table() prend en entrée un objet table (tableau de contingence avec les effectifs) et calcule les pourcentages (total, ligne, colonne) associés \\(\\rightarrow\\) ?prop.table (prop.table(t) * 100) %&gt;% round(digits = 1) ## ## 1 2 3 4 11 24 ## 111 - Grand pôle (plus de 10 000 emplois) 0.0 0.0 0.0 0.0 1.1 0.3 ## 112 - Couronne d&#39;un grand pôle 0.0 0.0 0.0 0.0 2.3 2.0 ## 120 - Multipolarisée des grandes aires urbaines 0.0 0.0 0.0 0.0 0.0 0.5 ## 211 - Moyen pôle (5 000 à 10 000 emplois) 0.0 0.0 0.0 0.0 0.0 0.1 ## 212 - Couronne d&#39;un moyen pôle 0.0 0.0 0.0 0.0 0.0 0.2 ## 221 - Petit pôle (de 1 500 à 5 000 emplois) 0.0 0.0 0.0 0.0 0.0 0.1 ## 222 - Couronne d&#39;un petit pôle 0.0 0.0 0.0 0.0 0.0 0.1 ## 300 - Autre commune multipolarisée 0.0 0.0 0.0 0.0 0.0 1.0 ## 400 - Commune isolée hors influence des pôles 0.0 0.0 0.0 0.0 0.0 0.7 ## ## 27 28 32 44 52 53 ## 111 - Grand pôle (plus de 10 000 emplois) 0.4 0.6 1.3 0.9 0.3 0.2 ## 112 - Couronne d&#39;un grand pôle 3.5 3.1 4.1 4.7 1.5 1.1 ## 120 - Multipolarisée des grandes aires urbaines 0.9 1.3 2.0 2.2 0.5 0.4 ## 211 - Moyen pôle (5 000 à 10 000 emplois) 0.1 0.1 0.1 0.1 0.1 0.1 ## 212 - Couronne d&#39;un moyen pôle 0.3 0.3 0.0 0.3 0.1 0.0 ## 221 - Petit pôle (de 1 500 à 5 000 emplois) 0.2 0.2 0.1 0.2 0.2 0.1 ## 222 - Couronne d&#39;un petit pôle 0.4 0.1 0.0 0.3 0.0 0.0 ## 300 - Autre commune multipolarisée 2.0 2.1 1.9 3.1 1.1 0.9 ## 400 - Commune isolée hors influence des pôles 2.6 1.1 0.8 2.2 0.4 0.5 ## ## 75 76 84 93 94 ## 111 - Grand pôle (plus de 10 000 emplois) 0.9 0.7 1.5 0.6 0.0 ## 112 - Couronne d&#39;un grand pôle 3.2 3.1 4.0 0.6 0.3 ## 120 - Multipolarisée des grandes aires urbaines 0.7 0.9 1.1 0.2 0.0 ## 211 - Moyen pôle (5 000 à 10 000 emplois) 0.1 0.2 0.1 0.1 0.0 ## 212 - Couronne d&#39;un moyen pôle 0.2 0.4 0.2 0.0 0.0 ## 221 - Petit pôle (de 1 500 à 5 000 emplois) 0.4 0.3 0.3 0.1 0.0 ## 222 - Couronne d&#39;un petit pôle 0.2 0.2 0.1 0.0 0.1 ## 300 - Autre commune multipolarisée 2.7 2.4 1.4 0.3 0.1 ## 400 - Commune isolée hors influence des pôles 3.8 4.2 2.6 0.7 0.4 7.6 Exercice : calcul de statistiques Utilisez la fonction summary() pour obtenir un résumé de l’ensemble des variables de la table df Calculez maintenant les moyenne, médiane, écart-type et variance de la variable de densité de population. Que constatez-vous ? Utilisez le paramètre na.rm = T pour gérer les valeurs manquantes Calulez à présent les quartiles puis déciles de cette variables Calculez la version centrée réduite de la variable de densité. Rappel : on calcule la version centrée réduite d’une variable X en lui appliquant la transformation suivante : \\[ STD_X =\\dfrac{X-\\bar{X}}{\\sigma_X}\\] où \\(\\bar{X}\\) est la moyenne empirique de X et \\(\\sigma_X\\) son écart-type Tableaux croisés : Calculer le nombre de communes par type d’espace à l’aide de la fonction table, et le pourcentage associé Calculer le nombre de communes par région et type d’espace, et les pourcentages associés df &lt;- base %&gt;% select(1:24) %&gt;% mutate(densite = P14_POP / SUPERF, tx_natal = 1000 * NAISD15 / P14_POP, tx_mort = DECESD15 / P14_POP, ZAU2 = as.factor(substr(ZAU, 1, 3))) # Parce que la variable originale est longue summary(df) ## CODGEO LIBGEO REG DEP ## 01001 : 1 Sainte-Colombe: 13 Min. : 1.00 62 : 895 ## 01002 : 1 Beaulieu : 11 1st Qu.:28.00 02 : 816 ## 01004 : 1 Saint-Sauveur : 11 Median :44.00 80 : 782 ## 01005 : 1 Sainte-Marie : 11 Mean :52.05 76 : 745 ## 01006 : 1 Le Pin : 10 3rd Qu.:76.00 57 : 730 ## 01007 : 1 Saint-Aubin : 10 Max. :94.00 14 : 707 ## (Other):36683 (Other) :36623 (Other):32014 ## ZAU ## 112 - Couronne d&#39;un grand pôle :12297 ## 400 - Commune isolée hors influence des pôles : 7383 ## 300 - Autre commune multipolarisée : 7021 ## 120 - Multipolarisée des grandes aires urbaines: 3962 ## 111 - Grand pôle (plus de 10 000 emplois) : 3285 ## 221 - Petit pôle (de 1 500 à 5 000 emplois) : 888 ## (Other) : 1853 ## ZE P14_POP P09_POP ## 0061 - Toulouse : 717 Min. : 0 Min. : 0 ## 2307 - Rouen : 501 1st Qu.: 197 1st Qu.: 193 ## 2210 - Amiens : 479 Median : 444 Median : 431 ## 7310 - Tarbes - Lourdes: 455 Mean : 1838 Mean : 1793 ## 2102 - Troyes : 452 3rd Qu.: 1110 3rd Qu.: 1072 ## 2603 - Dijon : 448 Max. :2220445 Max. :2234105 ## (Other) :33637 NA&#39;s :821 NA&#39;s :821 ## SUPERF NAIS0914 DECE0914 ## Min. : 0.04 Min. : 0.0 Min. : 0.00 ## 1st Qu.: 6.44 1st Qu.: 9.0 1st Qu.: 8.00 ## Median : 10.81 Median : 23.0 Median : 17.00 ## Mean : 17.64 Mean : 114.4 Mean : 77.35 ## 3rd Qu.: 18.58 3rd Qu.: 60.0 3rd Qu.: 43.00 ## Max. :18360.00 Max. :150843.0 Max. :69907.00 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 ## P14_MEN NAISD15 DECESD15 ## Min. : 0.0 Min. : 0.00 Min. : 0.00 ## 1st Qu.: 83.8 1st Qu.: 1.00 1st Qu.: 1.00 ## Median : 183.2 Median : 4.00 Median : 3.00 ## Mean : 802.0 Mean : 21.96 Mean : 16.47 ## 3rd Qu.: 454.9 3rd Qu.: 11.00 3rd Qu.: 9.00 ## Max. :1147990.9 Max. :28267.00 Max. :13997.00 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 ## P14_LOG P14_RP P14_RSECOCC ## Min. : 0.0 Min. : 0.0 Min. : 0.00 ## 1st Qu.: 115.0 1st Qu.: 83.8 1st Qu.: 7.00 ## Median : 239.1 Median : 183.2 Median : 19.00 ## Mean : 970.2 Mean : 802.0 Mean : 91.63 ## 3rd Qu.: 565.0 3rd Qu.: 454.9 3rd Qu.: 49.29 ## Max. :1362181.9 Max. :1147990.9 Max. :107061.99 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :821 ## P14_LOGVAC P14_RP_PROP NBMENFISC13 ## Min. : 0.00 Min. : 0.0 Min. : 32.0 ## 1st Qu.: 8.00 1st Qu.: 68.4 1st Qu.: 102.0 ## Median : 18.00 Median : 148.0 Median : 205.0 ## Mean : 76.60 Mean : 462.2 Mean : 809.7 ## 3rd Qu.: 43.75 3rd Qu.: 349.2 3rd Qu.: 484.0 ## Max. :107129.02 Max. :381934.3 Max. :1038789.0 ## NA&#39;s :821 NA&#39;s :821 NA&#39;s :3793 ## PIMP13 MED13 TP6013 P14_EMPLT ## Min. :24.46 Min. :10021 Min. : 5.00 Min. : 0.0 ## 1st Qu.:50.57 1st Qu.:18452 1st Qu.: 8.73 1st Qu.: 26.0 ## Median :58.40 Median :19844 Median :11.97 Median : 66.8 ## Mean :58.98 Mean :20250 Mean :13.35 Mean : 733.9 ## 3rd Qu.:67.19 3rd Qu.:21563 3rd Qu.:16.80 3rd Qu.: 229.5 ## Max. :89.38 Max. :46251 Max. :44.84 Max. :1801865.8 ## NA&#39;s :31598 NA&#39;s :3793 NA&#39;s :32531 NA&#39;s :821 ## densite tx_natal tx_mort ZAU2 ## Min. : 0.00 Min. : 0.000 Min. :0.0000 112 :12297 ## 1st Qu.: 18.59 1st Qu.: 5.679 1st Qu.:0.0044 400 : 7383 ## Median : 40.35 Median : 9.264 Median :0.0079 300 : 7021 ## Mean : 160.15 Mean : 9.699 Mean :0.0093 120 : 3962 ## 3rd Qu.: 94.57 3rd Qu.: 12.931 3rd Qu.:0.0124 111 : 3285 ## Max. :27126.14 Max. :111.111 Max. :0.1577 221 : 888 ## NA&#39;s :821 NA&#39;s :827 NA&#39;s :827 (Other): 1853 df %&gt;% pull(densite) %&gt;% mean() df %&gt;% pull(densite) %&gt;% sd() df %&gt;% pull(densite) %&gt;% median() df %&gt;% pull(densite) %&gt;% var() On a des NA car les valeurs manquantes sont absorbantes ! df %&gt;% pull(densite) %&gt;% mean(na.rm = T) df %&gt;% pull(densite) %&gt;% sd(na.rm = T) df %&gt;% pull(densite) %&gt;% median(na.rm = T) df %&gt;% pull(densite) %&gt;% var(na.rm = T) df &lt;- df %&gt;% mutate(std_dens = (densite - mean(densite, na.rm = T)) / sd(densite, na.rm = T)) Avantage des variables centrées réduites : on élimine les effets d’unité (d’ordre de grandeur), et on peut donc comparer les distributions de deux variables qui ont des unités différentes (voir module 3) df %&gt;% pull(densite) %&gt;% quantile(na.rm = T) ## 0% 25% 50% 75% 100% ## 0.00000 18.59047 40.35457 94.57430 27126.14108 seq(0, 1, 0.1) # vérifier la séquence qu&#39;on souhaite ## [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 df %&gt;% pull(densite) %&gt;% quantile(probs = seq(0, 1, 0.1), na.rm = T) ## 0% 10% 20% 30% 40% 50% ## 0.00000 10.03439 15.65357 21.84208 29.76144 40.35457 ## 60% 70% 80% 90% 100% ## 54.82089 77.65199 119.08740 240.40789 27126.14108 t &lt;- table(df$ZAU2) t ## ## 111 112 120 211 212 221 222 300 400 ## 3285 12297 3962 456 815 888 582 7021 7383 100 * prop.table(t) %&gt;% round(digits = 4) ## ## 111 112 120 211 212 221 222 300 400 ## 8.95 33.52 10.80 1.24 2.22 2.42 1.59 19.14 20.12 Deux variables t &lt;- table(df$REG, df$ZAU2) t ## ## 111 112 120 211 212 221 222 300 400 ## 1 17 6 1 0 0 3 0 2 3 ## 2 16 0 4 3 0 2 0 4 5 ## 3 3 3 0 2 0 1 0 0 13 ## 4 10 3 4 2 0 0 0 1 4 ## 11 413 853 3 3 2 0 0 7 0 ## 24 103 734 188 30 72 46 19 375 275 ## 27 140 1299 336 31 122 60 137 737 969 ## 28 216 1126 488 34 104 78 29 762 396 ## 32 481 1505 729 33 18 54 18 711 289 ## 44 322 1721 822 54 102 89 118 1155 815 ## 52 108 535 186 23 44 69 8 386 143 ## 53 89 415 152 47 18 42 1 325 181 ## 75 333 1161 254 51 81 163 81 1002 1379 ## 76 258 1124 333 79 155 123 89 877 1527 ## 84 548 1484 390 43 84 113 47 517 963 ## 93 220 229 69 20 11 32 6 107 269 ## 94 8 99 3 1 2 13 29 53 152 100 * prop.table(t) %&gt;% round(digits = 4) ## ## 111 112 120 211 212 221 222 300 400 ## 1 0.05 0.02 0.00 0.00 0.00 0.01 0.00 0.01 0.01 ## 2 0.04 0.00 0.01 0.01 0.00 0.01 0.00 0.01 0.01 ## 3 0.01 0.01 0.00 0.01 0.00 0.00 0.00 0.00 0.04 ## 4 0.03 0.01 0.01 0.01 0.00 0.00 0.00 0.00 0.01 ## 11 1.13 2.32 0.01 0.01 0.01 0.00 0.00 0.02 0.00 ## 24 0.28 2.00 0.51 0.08 0.20 0.13 0.05 1.02 0.75 ## 27 0.38 3.54 0.92 0.08 0.33 0.16 0.37 2.01 2.64 ## 28 0.59 3.07 1.33 0.09 0.28 0.21 0.08 2.08 1.08 ## 32 1.31 4.10 1.99 0.09 0.05 0.15 0.05 1.94 0.79 ## 44 0.88 4.69 2.24 0.15 0.28 0.24 0.32 3.15 2.22 ## 52 0.29 1.46 0.51 0.06 0.12 0.19 0.02 1.05 0.39 ## 53 0.24 1.13 0.41 0.13 0.05 0.11 0.00 0.89 0.49 ## 75 0.91 3.16 0.69 0.14 0.22 0.44 0.22 2.73 3.76 ## 76 0.70 3.06 0.91 0.22 0.42 0.34 0.24 2.39 4.16 ## 84 1.49 4.04 1.06 0.12 0.23 0.31 0.13 1.41 2.62 ## 93 0.60 0.62 0.19 0.05 0.03 0.09 0.02 0.29 0.73 ## 94 0.02 0.27 0.01 0.00 0.01 0.04 0.08 0.14 0.41 Pour aller plus loin et ajouter des variables de pondération, calculer les profils-ligne ou profils-colonne, rendez-vous au module 3 “Statistiques descriptives”, ou demandez à votre GF (Gentil Formateur). "],
["premiers-graphiques.html", "Chapitre 8 Premiers graphiques 8.1 Package ggplot2 8.2 Histogramme 8.3 Nuages de points 8.4 Matrice de nuages 8.5 Bonus : faire un graphique “dynamique” 8.6 Exercices : créer des graphiques", " Chapitre 8 Premiers graphiques 8.1 Package ggplot2 Pour réaliser des graphiques, nous choisissons de nous servir du package ggplot2, qui permet de faire de meilleures réalisations que les fonctions basiques. Il est intégré dans le méta-package tidyverse donc il n’est pas utile de le re-charger dans notre session. Mais si vous devez le faire, le code est le suivant : install.packages(&quot;ggplot2&quot;) library(&quot;ggplot2&quot;) La fonction ggplot() fonctionne d’une manière particulière. La structure ressemble à ceci : ggplot(TableEnEntree, aes(VariablesATracer)) + geom_FonctionAChoisir() Pour découvrir les nombreuses possibilités de ggplot2, vous pouvez vous référer au Module 5 : « Datavisualisation : produire des graphiques, des cartes et des tableaux » ou consulter les sites suivants : Version anglaise Version française La fonction aes() (pour “aesthetics”), utilisée dans l’instrution ggplot() permet de définir les données à tracer. On y indique les dimensions que l’on veut représenter sur le graphique. On peut représenter jusqu’à 5 dimensions sur un même graphique, mais attention à la lisibilité ! 2 variables quanti : x en fonction de y \\(\\rightarrow\\) 2 dimensions (nuage de points) taille du point \\(\\rightarrow\\) 3e dimension (quanti) couleur des points \\(\\rightarrow\\) 4e dimension (quali) juxtaposer des graphiques en fonction d’une variable quali \\(\\rightarrow\\) 5e dimension ! 8.2 Histogramme Si on désire un histogramme de log_SUPERF, on fera appel à la fonction geom_histogram(). Ce graphique ne présente qu’une seule dimension (la variable quanti dont on veut visualiser la distribution) rm(list = ls()) base &lt;- read.csv(file = &quot;data/Base_synth_territoires.csv&quot;, header = T, sep=&quot;;&quot;, dec=&quot;,&quot;) %&gt;% select(1:24) %&gt;% mutate(log_SUPERF = log (SUPERF), REG = as.factor (REG), densite = P14_POP / SUPERF, tx_natal = 1000 * NAISD15 / P14_POP, tx_mort = DECESD15 / P14_POP) ggplot(base, aes(x = log_SUPERF)) + geom_histogram() 8.3 Nuages de points Selon les graphiques que l’on veut tracer, on peut renseigner plusieurs variables. Dans le cas d’un nuage de points, par exemple, on croise 2 variables quantitatives : ggplot(base, aes(x = P14_EMPLT, y = MED13)) + geom_point(colour = &quot;blue&quot;) ggplot(base, aes(x = log (P14_EMPLT), y = log(MED13))) + geom_point(colour = &quot;blue&quot;) 8.4 Matrice de nuages Pour explorer son jeu de données, on peut décider de réaliser un nuage de points pour plusieurs croisements de variables possibles. Ici, en conservant quelques variables quantitatives, on peut réaliser un ensemble de graphiques. Cette “matrice” de nuage fonctionne avec le package GGally. # install.packages(&quot;GGally&quot;) library(&quot;GGally&quot;) num &lt;- select(base, P14_LOGVAC:PIMP13) %&gt;% sample_n(10000) %&gt;% log() ggpairs(num) ## fonction ggpairs() de GGally 8.5 Bonus : faire un graphique “dynamique” Une fois qu’on a généré un graphique avec ggplot, on peut le passer dans la fonction ggplotly() (package plotly) qui permet de le rendre dynamique. library(plotly) g &lt;- ggplot(data = base, aes(x = REG, fill = REG)) + geom_bar() ggplotly(g) 8.6 Exercices : créer des graphiques A l’aide de l’aide mémoire ggplot2 : Réaliser un histogramme de la population communale Transformer les données avec la fonction log pour y voir plus clair Faire un barplot du nombre de communes par type ZAU Utiliser le paramètre fill de la fonction aes() pour améliorer le graphique Réaliser un graphique (nuage de points) croisant la densité de population et le taux de mortalité Ajouter une dimension supplémentaire avec la couleur des points (paramètre color de aes()) ggplot(data = base, aes(x = P14_POP)) + geom_histogram() Ce n’est pas très informatif, mais on peut faire une transformation log pour y voir plus clair ! ggplot(data = base, aes(x = log(P14_POP))) + geom_histogram() Faites maintenant un barplot (qui n’est pas un histogramme !!!! ) du nombre de communes par type ZAU ggplot(data = base, aes(x = REG)) + geom_bar() On va essayer d’y voir plus clair avec le paramètre fill ggplot(data = base, aes(x = REG, fill = REG)) + geom_bar() ggplot(data = base, aes(x = log(P14_POP), y = log(P14_LOGVAC))) + geom_point() ggplot(data = base, aes(x = densite, y = tx_mort, color = REG)) + geom_point() Là encore il faudrait faire une transformation logarithmique, mais tout ça est abordé dans le module 3 ! Note : avec les fonctions de base, on peut obtenir de nombreux graphiques avec très peu de code, mais moins jolis : plot(iris) Des possibilités infinies à approfondir dans les modules 3 et 5 !! "],
["sauvegarder-son-travail.html", "Chapitre 9 Sauvegarder son travail 9.1 Exportation des résultats 9.2 Environnement et .RData", " Chapitre 9 Sauvegarder son travail Après avoir réalisé ces traitements, on peut exporter son travail afin de le finaliser dans un tableur ou un traitement de texte en vue d’une publication ou autre. On peut donc avoir à exporter soit des tableaux qu’on retouchera par la suite, soit des images de ses graphiques qu’on intégrera dans un document. Une dernière possibilité consiste à sauvegarder un ensemble d’objets R dans un seul fichier (RData) afin de retrouver son environnement de travail facilement en rouvrant une session de R. 9.1 Exportation des résultats Exporter une table en csv res &lt;- summary(base) write.table(x = res, file = &#39;outputs/resultat_R.csv&#39;, sep = &#39;;&#39;, row.names = F) # row.names=F pour éviter un décalage entre première ligne et les suivantes write.table(x = base, file = &#39;outputs/base_R.csv&#39;, sep = &#39;;&#39;, row.names = F) Exporter un graphique pour l’intégrer à un document png(&#39;outputs/mongraphe.png&#39;) # Alloue et ouvre le fichier où inscrire le graphe ggplot(base, aes(x = P14_EMPLT, y = MED13)) + geom_point(colour = &quot;blue&quot;) dev.off() # Ferme le fichier \\(\\rightarrow\\) Beaucoup d’autres fonctions : jpeg, pdf, postscript, svg… 9.2 Environnement et .RData Il est possible de sauvegarder des objets R (dataframe, vecteur, etc…) directement sur son ordinateur. Une liste d’objets R est enregistrée sous le format .RData. save(list = ls(), file = &quot;outputs/env_entier.RData&quot;) # sauvegarde de tout l&#39;environnement sur le répertoire choisi rm(list = ls()) # suppression de notre environnement dans R load(&quot;outputs/env_entier.RData&quot;) # chargement de l&#39;environnement stocké sur l&#39;ordinateur save(base, V1, file = &quot;outputs/petit_env.RData&quot;) # sauvegarde des éléments base et V1 rm(list = ls()) # suppression de notre environnement load(outputs/&quot;petit_env.RData&quot;) Avantages - Un seul fichier peut contenir des dataframes, des graphiques, des fonctions, etc. - La lecture est très rapide \\(\\Rightarrow\\) utile pour les gros volumes "],
["aller-plus-loin-avec-les-objets-crochets-et-la-programmation-fonctionnelle.html", "Chapitre 10 Aller plus loin avec les objets, crochets et la programmation fonctionnelle 10.1 Les objets dans R 10.2 Sélectionner des lignes et des colonnes 10.3 Créer une nouvelle fonction en R 10.4 Les boucles conditionnelles 10.5 Les boucles 10.6 Exercices", " Chapitre 10 Aller plus loin avec les objets, crochets et la programmation fonctionnelle Ce qui a été présenté dans ce module repose sur les fonctions du package tidyverse. Cette approche tend à se généraliser depuis quelques années, mais quand on cherche la réponse à un problème sur Internet, on trouve d’autres façons de programmer en R, qui font appel aux fonctions du package base et non du tidyverse \\(\\Rightarrow\\) Cette partie donne quelques clés de compréhension. 10.1 Les objets dans R Rappel : en informatique, un objet est défini par : ses attributs et ses méthodes (fonctions). Dans l’exemple du jeu d’échec, chaque pièce peut être vue comme un objet : sa position sur le plateau constitue ses attributs sa façon de se déplacer peut être vue comme une fonction qui ne s’applique qu’à ce type de pièce, donc une méthode R est un langage orienté objet ; ces objets permettent de structurer les données selon leurs caractéristiques \\(\\Rightarrow\\) on retrouve les données dans les attributs. Les méthodes sont en général transparentes pour l’utilisateur (cf. utilisation des fonctions summary, plot…). Les objets les plus courants sont les suivants : Vecteurs : suite unidimensionnelle de valeurs ayant le même type. Facteurs : vecteur qui prend un nombre limité de modalités (exemple : sexe). Il est défini par les niveaux (levels) et les libellés associés (labels). Matrice et arrays : suites multidimensionnelles de valeurs (matrices=dimension 2 ; array=dimension n). Liste : ensemble d’objets différents. On peut stocker un vecteur alphanumérique + une matrice numérique dans une liste. Tableaux (data.frame) : Objet qui ressemble le plus aux tables Excel, SAS ou SPSS… : description d’individus statistiques (observations, en ligne) par des caractéristiques (variables, en colonnes). Fonctions : Objets particuliers qui donnent un résultat à partir de paramètres en entrée. Autres objets : Il existe un très grand nombre d’objets ad hoc dans R. Par exemple ts (time serie) pour les séries temporelles, lm (linear model) qui contient tous les résultats d’une régression linéraire… des graphiques On peut même en définir de nouveaux soi-même ! La fonction c permet de lister simplement les valeurs que l’on veut stocker dans l’objet ; la fonction seq génére une suite incrémentée. Il existe aussi la fonction rep qui réplique n fois la même valeur. 10.1.1 Créer des vecteurs v1 &lt;- seq(1 : 10) v2 &lt;- c (&quot;lundi&quot;, &quot;mardi&quot;, &quot;mercredi&quot;, &quot;jeudi&quot;, &quot;vendredi&quot;, &quot;samedi&quot;, &quot;dimanche&quot;) 10.1.2 Créer une matrice m &lt;- matrix (v1, nrow = 10, ncol = 7) l &lt;- list (v1, v2, m) 10.1.3 Visualiser ces objets et leurs attributs Quelques fonctions simples : print, View, names, colnames, rownames, typeof, str, dim v1 ## [1] 1 2 3 4 5 6 7 8 9 10 print (v2) ## [1] &quot;lundi&quot; &quot;mardi&quot; &quot;mercredi&quot; &quot;jeudi&quot; &quot;vendredi&quot; &quot;samedi&quot; ## [7] &quot;dimanche&quot; typeof (v2) # Permet de visualiser le type ## [1] &quot;character&quot; dim (m) ## [1] 10 7 str (l) # Permet de visualiser les attributs ## List of 3 ## $ : int [1:10] 1 2 3 4 5 6 7 8 9 10 ## $ : chr [1:7] &quot;lundi&quot; &quot;mardi&quot; &quot;mercredi&quot; &quot;jeudi&quot; ... ## $ : int [1:10, 1:7] 1 2 3 4 5 6 7 8 9 10 ... 10.2 Sélectionner des lignes et des colonnes Il est aussi possible d’accéder aux éléments d’un dataframe à partir du numéro de ligne et de colonne, grâce aux crochets : base[1,3] \\(\\rightarrow\\) valeur de la première ligne et de la troisième colonne base[2,] \\(\\rightarrow\\) toutes les variables pour la 2e observation base[,4] \\(\\rightarrow\\) toutes les observations de la quatrième colonne base[,’V6’] \\(\\rightarrow\\) toutes les observations de la variable V6 \\(\\Rightarrow\\) Utile pour sélectionner une partie d’une table : base[1:4, c(3, 6)] 10.3 Créer une nouvelle fonction en R La fonction est un objet comme les autres, qu’on crée avec l’opérateur d’affectation. Elle est définie par des paramètres et elle se termine par la fonction return(). On reprend l’exemple du calcul de l’IMC calcul_IMC &lt;- function (poids, taille) { ## La taille est exprimée en mètres imc &lt;- poids / taille ^ 2 return (imc) } calcul_IMC (poids = 80, taille = 1.89) ## [1] 22.39579 calcul_IMC (poids = 60, taille = 1.55) ## [1] 24.97399 10.4 Les boucles conditionnelles Les commandes if et else sont bien entendues utilisables. Le “then” n’existe pas : il est implicite après les accolades. diag_IMC &lt;- function(poids,taille) { imc &lt;- poids / taille ^ 2 if (imc &lt; 18.5) {diag &lt;- &quot;maigre&quot;} else if (imc &lt; 25) {diag &lt;- &quot;normal&quot;} else {diag &lt;- &quot;surpoids&quot;} return (diag) } diag_IMC (poids=60,taille=1.89) ## [1] &quot;maigre&quot; diag_IMC (poids=80,taille=1.89) ## [1] &quot;normal&quot; diag_IMC (poids=80,taille=1.55) ## [1] &quot;surpoids&quot; 10.5 Les boucles On peut utiliser les boucles classiques : repeat, while, for : for (pp in seq(from = 50, to = 100, by = 5)) { print(paste (&quot;Taille = 1,70m, poids =&quot;, pp, &quot;Diagnotic :&quot;, diag_IMC (poids = pp, taille = 1.70))) } ## [1] &quot;Taille = 1,70m, poids = 50 Diagnotic : maigre&quot; ## [1] &quot;Taille = 1,70m, poids = 55 Diagnotic : normal&quot; ## [1] &quot;Taille = 1,70m, poids = 60 Diagnotic : normal&quot; ## [1] &quot;Taille = 1,70m, poids = 65 Diagnotic : normal&quot; ## [1] &quot;Taille = 1,70m, poids = 70 Diagnotic : normal&quot; ## [1] &quot;Taille = 1,70m, poids = 75 Diagnotic : surpoids&quot; ## [1] &quot;Taille = 1,70m, poids = 80 Diagnotic : surpoids&quot; ## [1] &quot;Taille = 1,70m, poids = 85 Diagnotic : surpoids&quot; ## [1] &quot;Taille = 1,70m, poids = 90 Diagnotic : surpoids&quot; ## [1] &quot;Taille = 1,70m, poids = 95 Diagnotic : surpoids&quot; ## [1] &quot;Taille = 1,70m, poids = 100 Diagnotic : surpoids&quot; 10.6 Exercices 10.6.1 Vecteurs simples Créer trois vecteurs : un numérique, un caractère et un facteur. Vous pouvez vous aider des fonctions c(), rnorm() (génération d’une variable aléatoire selon une loi normale), seq() ou rep() Regrouper ces variables dans un dataframe, puis dans une liste. Dans les deux configurations, afficher la variable contenant les tailles (vtaille). Pour la liste, utiliser les [] et [[]]. rm (list = ls ()) x &lt;- c (1, 160, 2, 9, 60) x1 &lt;- c(&quot;Je&quot;, &quot;programme&quot;, &quot;en&quot;, &quot;R&quot;) # Guillemets pour indiquer que c&#39;est une variable textuelle y &lt;- seq (from = 1, to = 10, by = 1) z &lt;- rep (x = 1, times = 100) x &lt;- rnorm (n = 30) # création de vecteurs avec la fonction c() = combine v1 &lt;- c( 3, 4, 12, 15, 32, 6, 1, 2, 3, 9) # avec la fonction seq() = sequence, généralisation de la syntaxe ci-dessus v2 &lt;- seq(from = 1 , to = 15 , by = 1.5) # syntaxe équivalente mais préférable car plus lisible : v2b &lt;- seq (from=1, to=15, by=1.5) v3 &lt;- 1:10 # avec la fonction rep() = répétition v4 &lt;- rep (x = 4, times = 10) # ces commandes peuvent être combinées. Pratique pour créer des variables &quot;facteur&quot; v5 &lt;- rep (x = c(3, 4, 1.2, 8, 9), times = 2) v6 &lt;- rep (x = 1:5, times = 2) # vecteurs de type texte ou factor vtaille &lt;- rep (x = c (&quot;S&quot;, &quot;L&quot;), times = 5) vtaille &lt;- factor (vtaille) # concaténation de vecteurs gtaille &lt;- paste(&quot;X&quot;, vtaille, sep = &quot;&quot;) gtaille &lt;- factor (gtaille) toutes_taille &lt;- c (as.character (vtaille), as.character (gtaille)) toutes_taille &lt;- as.factor (toutes_taille) levels (toutes_taille) ## [1] &quot;L&quot; &quot;S&quot; &quot;XL&quot; &quot;XS&quot; 10.6.2 Dataframes et listes dataf &lt;- data.frame (vtaille, v1, v2, v3, v4, v5, v6) liste &lt;- list (vtaille, v1, v2, v3, v4, v5, v6) names(liste) &lt;- c (&quot;vtaille&quot;, &quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;, &quot;v4&quot;, &quot;v5&quot;, &quot;v6&quot;) dataf$vtaille ## [1] S L S L S L S L S L ## Levels: L S liste$vtaille ## [1] S L S L S L S L S L ## Levels: L S rm (dataf, vtaille, v1, v2, v2b, v3, v4, v5, v6) 10.6.3 Pour aller plus loin : matrices et arrays Les matrices et les arrays permettent des calculs rapides et efficaces, et peuvent être très pratiques et optimisent le stockage des données. Ils demandent cependant plus de réflexion en amont quant à leur utilisation, mais . On accède aux éléments avec les []. Créer une matrice à 10 lignes et 10 colonnes remplie avec un tirage aléatoire selon une loi normale centrée réduit. Créer un hypercube avec la fonction array() avec 10 lignes, 5 colonnes et de profondeur 3, toujours avec un tirage aléatoire selon une loi normale Un hypercube de trois dimensions peut être représenté comme suit : mat &lt;- matrix(rnorm(50), ncol = 5, nrow = 10) arr &lt;- array(rnorm(150),dim = c(10,5,3)) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] -0.68493800 -0.3314770 -0.91533064 0.23247056 -0.47622259 ## [2,] -0.67820879 1.0300161 0.99697558 -1.22107088 1.18670668 ## [3,] 1.89314225 -1.1536359 0.21703338 -0.10000272 -0.20649698 ## [4,] 0.50330003 0.2108075 -0.06588234 0.53184325 0.97051945 ## [5,] 0.07280369 1.3985436 -0.37058409 1.24185200 1.00156167 ## [6,] -2.15010387 1.5134278 -0.31171257 -0.60720471 -0.64865598 ## [7,] -0.18386150 -1.1297428 -0.26825577 0.29541509 0.03114267 ## [8,] 0.95708241 1.3464300 -0.78463017 0.73269832 0.49682302 ## [9,] -0.19203915 1.1272268 -0.10027205 1.61094664 1.31785794 ## [10,] 1.81936970 0.5082678 1.64983724 -0.08671501 0.29674756 arr ## , , 1 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.6480522 0.2876557 -1.36882212 0.7086237 -1.5607903 ## [2,] -0.8968573 -0.4766395 0.22362410 -2.0584134 -0.9251396 ## [3,] -0.1973113 -0.2314617 0.84940054 -1.3590186 -2.4389110 ## [4,] 0.1127159 -0.4705643 -0.95484074 -0.3474656 1.9055604 ## [5,] 0.2810605 0.3307132 1.06892511 -0.6810601 -0.4332195 ## [6,] -0.2461152 1.6745599 -0.76533357 -0.8434536 -1.0110255 ## [7,] -1.2553787 0.2370073 -1.08502404 0.3086622 0.2700255 ## [8,] -0.4583310 1.9562366 -0.01745874 0.3473191 1.4062079 ## [9,] -0.1964143 1.4848400 1.30653942 1.5566407 1.1321518 ## [10,] 0.2407209 -0.4021123 1.01571892 -0.6393971 -1.4438230 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.8279404 0.7175146 -0.66287595 -0.8175620 0.9180991 ## [2,] 1.5971553 -0.2015095 0.52076283 -1.6827987 -0.3075335 ## [3,] -0.0658732 0.2240584 -0.76156348 0.5874301 -0.4073195 ## [4,] 0.3216030 0.5519203 0.60149517 -0.4014834 -0.4399326 ## [5,] -0.0583456 0.2769523 -0.09266041 0.5204357 -0.8109080 ## [6,] -0.2389302 0.8503584 0.89097008 0.9694475 -0.7681425 ## [7,] -1.4155777 0.5815041 1.40259002 0.6475972 -1.4010874 ## [8,] -0.2096668 -1.4028309 0.66463129 0.4052988 -1.0191170 ## [9,] -0.1606451 -2.0134796 0.09017294 -0.9986682 -2.2175283 ## [10,] 0.6096606 -0.6076346 0.60785440 -0.3026600 0.8825602 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] [,5] ## [1,] -0.42194766 1.45829879 -1.7472051 0.5156990 0.6105364 ## [2,] 0.88830153 0.04628931 -0.8570173 -1.6314301 1.5313047 ## [3,] 0.05824859 0.63802390 -0.5648198 1.0947927 -0.5471933 ## [4,] -1.87113294 -0.67698090 -0.7220651 -0.2688367 1.1300641 ## [5,] 0.21900761 0.31457711 0.7714861 -1.4071037 0.9076674 ## [6,] -1.72964306 1.64144717 -0.3091499 0.7381537 -1.7195156 ## [7,] 0.82839946 0.35375369 -1.3769677 -1.8236617 0.5065924 ## [8,] 0.46952220 0.93724067 -0.1459426 1.6532392 -1.2120104 ## [9,] -0.38191649 0.64132735 -1.1208490 -0.1809339 -1.2982689 ## [10,] -0.67920816 -1.64411471 0.7570896 1.6015246 -2.0590886 Pourquoi s’embêter avec ça ? Parce qu’on peut appliquer des fonctions facilement sur les lignes, colonnes et autres dimensions grâce à la fonction apply(). Exemple : résultats de validations croisées par bloc, simulations de loi selon différents paramètres. Et on calcule facilement des statistiques “marginales”. Par, exemple, sur une matrice, on peut calculer des statistiques par lignes : apply(mat, MARGIN = 1, FUN=mean) ## [1] -0.4350995 0.2628837 0.1300080 0.4301176 0.6688354 -0.4408499 ## [7] -0.2510605 0.5496807 0.7527440 0.8375014 Ou par colonnes : apply(mat, MARGIN = 2, FUN=mean) ## [1] 0.135654677 0.451986387 0.004717857 0.263023253 0.396998343 Sur notre hypercube de type array, on peut aussi calculer des stats sur ses différentes dimensions : apply (arr, MARGIN = 3, FUN=mean) ## [1] -0.06822841 -0.06396642 -0.12168832 apply (arr, MARGIN = c(2,3), FUN = mean) ## [,1] [,2] [,3] ## [1,] -0.19678581 0.1207321 -0.26203689 ## [2,] 0.43902347 -0.1023146 0.37098624 ## [3,] 0.02727289 0.3261377 -0.53154407 ## [4,] -0.30075627 -0.1072963 0.02914431 ## [5,] -0.30989633 -0.5570909 -0.21499117 Le coin du capitaine [ ] Le crochet, c’est comme le capitaine du même nom : personne ne l’aime, mais sans lui, pas de Peter Pan, pas de Neverland ! Moralité, on s’en sert beacoup pour pimenter les codes ! On peut utiliser les crochets pour accéder aux éléments des matrices/arrays et dataframe/listes. Matrices et arrays mat [1,1] ## [1] -0.684938 mat [1,] ## [1] -0.6849380 -0.3314770 -0.9153306 0.2324706 -0.4762226 mat [,1] ## [1] -0.68493800 -0.67820879 1.89314225 0.50330003 0.07280369 ## [6] -2.15010387 -0.18386150 0.95708241 -0.19203915 1.81936970 arr [1,1,1] ## [1] 0.6480522 arr [1,,] ## [,1] [,2] [,3] ## [1,] 0.6480522 0.8279404 -0.4219477 ## [2,] 0.2876557 0.7175146 1.4582988 ## [3,] -1.3688221 -0.6628760 -1.7472051 ## [4,] 0.7086237 -0.8175620 0.5156990 ## [5,] -1.5607903 0.9180991 0.6105364 arr [,,1] ## [,1] [,2] [,3] [,4] [,5] ## [1,] 0.6480522 0.2876557 -1.36882212 0.7086237 -1.5607903 ## [2,] -0.8968573 -0.4766395 0.22362410 -2.0584134 -0.9251396 ## [3,] -0.1973113 -0.2314617 0.84940054 -1.3590186 -2.4389110 ## [4,] 0.1127159 -0.4705643 -0.95484074 -0.3474656 1.9055604 ## [5,] 0.2810605 0.3307132 1.06892511 -0.6810601 -0.4332195 ## [6,] -0.2461152 1.6745599 -0.76533357 -0.8434536 -1.0110255 ## [7,] -1.2553787 0.2370073 -1.08502404 0.3086622 0.2700255 ## [8,] -0.4583310 1.9562366 -0.01745874 0.3473191 1.4062079 ## [9,] -0.1964143 1.4848400 1.30653942 1.5566407 1.1321518 ## [10,] 0.2407209 -0.4021123 1.01571892 -0.6393971 -1.4438230 dataframes et listes : Pour les dataframes, le fonctionnement est le même que pour les matrices. Pour les listes, une paire de crochet renvoie un résultat sous forme de liste, un double crochet renvoie le résultat sous sa forme naturelle (ex : vecteur ou matrice). str (liste [1]) ## List of 1 ## $ vtaille: Factor w/ 2 levels &quot;L&quot;,&quot;S&quot;: 2 1 2 1 2 1 2 1 2 1 str (liste [[1]]) ## Factor w/ 2 levels &quot;L&quot;,&quot;S&quot;: 2 1 2 1 2 1 2 1 2 1 liste[&quot;v6&quot;] ## $v6 ## [1] 1 2 3 4 5 1 2 3 4 5 liste[c(&quot;v6&quot;, &quot;v5&quot;)] ## $v6 ## [1] 1 2 3 4 5 1 2 3 4 5 ## ## $v5 ## [1] 3.0 4.0 1.2 8.0 9.0 3.0 4.0 1.2 8.0 9.0 Dans la syntaxe tidyverse, on ne met pas (obligatoirement) de guillemets pour les noms de variable, alors qu’on le fait pour la version [ ]. 10.6.4 Inspection d’un objet : la régression La régression linéaire consiste à exprimer une variable Y en fonction d’une variable X dans une fonction linéaire. C’est à dire qu’on cherche a et b tels que : \\[ Y = a \\cdot X + b + \\epsilon\\] où \\(\\epsilon\\) est le résidu de la régression. On utilise dans cet exemple la table des iris de Fisher, existant dans R base qu’il suffit d’appeler avec data(iris) (il existe d’autres dataframe inclus dans les packages et qui sont utilisés en exemple dans l’aide). data (&quot;iris&quot;) str (iris) ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... Faire la régression de la Sepal.Length sur Petal.length à l’aide de la fonction lm() lm (data = iris, formula = Sepal.Length ~ Petal.Length) ## ## Call: ## lm(formula = Sepal.Length ~ Petal.Length, data = iris) ## ## Coefficients: ## (Intercept) Petal.Length ## 4.3066 0.4089 On a les paramètres a et b mais on aimerait en savoir plus… Au moins la qualité d’ajustement (le \\(R^2\\) par exemple), et un graphique des résidus pour détecter une éventuelle structure. Pour cela, stocker le résultat dans un nouvel objet, et explorez-le avec les fonctions str(), summary() et plot() reg &lt;- lm(data = iris, formula = Sepal.Length ~ Petal.Length) str (reg) ## List of 12 ## $ coefficients : Named num [1:2] 4.307 0.409 ## ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;(Intercept)&quot; &quot;Petal.Length&quot; ## $ residuals : Named num [1:150] 0.2209 0.0209 -0.1382 -0.32 0.1209 ... ## ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ effects : Named num [1:150] -71.566 8.812 -0.155 -0.337 0.104 ... ## ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;(Intercept)&quot; &quot;Petal.Length&quot; &quot;&quot; &quot;&quot; ... ## $ rank : int 2 ## $ fitted.values: Named num [1:150] 4.88 4.88 4.84 4.92 4.88 ... ## ..- attr(*, &quot;names&quot;)= chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## $ assign : int [1:2] 0 1 ## $ qr :List of 5 ## ..$ qr : num [1:150, 1:2] -12.2474 0.0816 0.0816 0.0816 0.0816 ... ## .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. ..$ : chr [1:150] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## .. .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;Petal.Length&quot; ## .. ..- attr(*, &quot;assign&quot;)= int [1:2] 0 1 ## ..$ qraux: num [1:2] 1.08 1.1 ## ..$ pivot: int [1:2] 1 2 ## ..$ tol : num 1e-07 ## ..$ rank : int 2 ## ..- attr(*, &quot;class&quot;)= chr &quot;qr&quot; ## $ df.residual : int 148 ## $ xlevels : Named list() ## $ call : language lm(formula = Sepal.Length ~ Petal.Length, data = iris) ## $ terms :Classes &#39;terms&#39;, &#39;formula&#39; language Sepal.Length ~ Petal.Length ## .. ..- attr(*, &quot;variables&quot;)= language list(Sepal.Length, Petal.Length) ## .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. ..$ : chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## .. .. .. ..$ : chr &quot;Petal.Length&quot; ## .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;Petal.Length&quot; ## .. ..- attr(*, &quot;order&quot;)= int 1 ## .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. ..- attr(*, &quot;response&quot;)= int 1 ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. ..- attr(*, &quot;predvars&quot;)= language list(Sepal.Length, Petal.Length) ## .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## $ model :&#39;data.frame&#39;: 150 obs. of 2 variables: ## ..$ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## ..$ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## ..- attr(*, &quot;terms&quot;)=Classes &#39;terms&#39;, &#39;formula&#39; language Sepal.Length ~ Petal.Length ## .. .. ..- attr(*, &quot;variables&quot;)= language list(Sepal.Length, Petal.Length) ## .. .. ..- attr(*, &quot;factors&quot;)= int [1:2, 1] 0 1 ## .. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2 ## .. .. .. .. ..$ : chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## .. .. .. .. ..$ : chr &quot;Petal.Length&quot; ## .. .. ..- attr(*, &quot;term.labels&quot;)= chr &quot;Petal.Length&quot; ## .. .. ..- attr(*, &quot;order&quot;)= int 1 ## .. .. ..- attr(*, &quot;intercept&quot;)= int 1 ## .. .. ..- attr(*, &quot;response&quot;)= int 1 ## .. .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_GlobalEnv&gt; ## .. .. ..- attr(*, &quot;predvars&quot;)= language list(Sepal.Length, Petal.Length) ## .. .. ..- attr(*, &quot;dataClasses&quot;)= Named chr [1:2] &quot;numeric&quot; &quot;numeric&quot; ## .. .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Sepal.Length&quot; &quot;Petal.Length&quot; ## - attr(*, &quot;class&quot;)= chr &quot;lm&quot; summary (reg) ## ## Call: ## lm(formula = Sepal.Length ~ Petal.Length, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.24675 -0.29657 -0.01515 0.27676 1.00269 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.30660 0.07839 54.94 &lt;2e-16 *** ## Petal.Length 0.40892 0.01889 21.65 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.4071 on 148 degrees of freedom ## Multiple R-squared: 0.76, Adjusted R-squared: 0.7583 ## F-statistic: 468.6 on 1 and 148 DF, p-value: &lt; 2.2e-16 plot (reg) Les méthodes summary, print et plot sont implémentées pour tous les objets en R, et on peut les utiliser pour avoir un premier aperçu de ce que l’on obtient avec la fonction. "]
]
